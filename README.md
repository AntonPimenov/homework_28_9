# Задание
## 
    Доработайте алгоритм merge sort, сделав его многопоточным.
    Используйте std::futurez в качестве инструмента для синхронизации результата работы потоков.
    Нужно определить независимые части алгоритма, 
    которые могут быть распараллелены и запустить их вычисление в отдельных потоках.
    Потоки могут быть запущены через std::thread или std::async, 
    но синхронизация строго через std::future. 
    Также предусмотрите ограничение количества запускаемых потоков.

## Основные шаги:

    Разделение массива:

        Рекурсивно разделяем массив на две части до тех пор, 
        пока размер части не станет меньше определенного порога (например, 1000 элементов). 
        Это позволит избежать создания слишком большого количества потоков.

    Параллельная сортировка:

        Если размер массива больше порога, 
        запускаем сортировку левой и правой частей в отдельных потоках с использованием std::async.

        Если размер массива меньше порога, выполняем сортировку последовательно.

    Синхронизация через std::future:

        Используем std::future для получения результатов работы потоков.

    Ограничение количества потоков:

        Используем счетчик активных потоков, чтобы ограничить их количество.

## Объяснение кода:

    Порог для последовательной сортировки (SEQUENTIAL_THRESHOLD):

        Если размер массива меньше этого порога, сортировка выполняется последовательно. 
        Это позволяет избежать создания слишком большого количества потоков.

    Счетчик активных потоков (active_threads):

        Используется для ограничения количества одновременно работающих потоков. 
        Мы увеличиваем счетчик при запуске потоков и уменьшаем при их завершении.

    Рекурсивная функция merge_sort:

        Если размер массива больше порога и количество активных потоков не превышает лимит, 
        левая и правая части сортируются в отдельных потоках с использованием std::async.

        Если лимит потоков достигнут, сортировка выполняется последовательно.

    Слияние (merge):

        После завершения сортировки левой и правой частей выполняется их слияние.

    Генерация случайного массива:

        Функция generate_random_array создает массив заданного размера и 
        заполняет его случайными числами от 0 до 9999 с использованием rand().

        srand(time(0)) инициализирует генератор случайных чисел текущим временем, 
        чтобы при каждом запуске программы массив был разным.

    Многопоточная версия (merge_sort_mt):

        Использует std::async для запуска сортировки левой и правой частей массива в отдельных потоках.

        Ограничивает количество потоков с помощью счетчика active_threads.

    Однопоточная версия (merge_sort_st):

        Выполняет сортировку последовательно без использования потоков.

    Замер времени:

        Используется std::chrono::high_resolution_clock для измерения времени выполнения многопоточной и однопоточной версий.

    Сравнение производительности:

        В конце программы выводятся время выполнения многопоточной и однопоточной версий для сравнения.   

### Преимущества:
    Генерация случайного массива позволяет тестировать алгоритм на разных данных.

    Сравнение многопоточной и однопоточной версий помогает оценить эффективность параллелизации.

    Ограничение количества потоков предотвращает перегрузку системы.